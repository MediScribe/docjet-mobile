# Offline-First Data Sync Libraries for Flutter

Building a **local-first/offline-first** Flutter app (with data persisted locally and synced to a REST API backend) is complex, but several libraries aim to simplify this. These tools handle local data persistence (often via an embedded database), queue offline changes, sync in the background when online, and sometimes offer basic conflict resolution (typically *last-write-wins* logic). Below are some notable packages and solutions, with their capabilities and trade-offs:

## Flutter Data (offline-first framework)  
**Link:** [flutter_data on pub.dev](https://pub.dev/packages/flutter_data) – *by GitHub user frank06*  

**Summary:** Flutter Data is a comprehensive offline-first data framework inspired by Ember Data. It generates repositories for your models and uses a local Hive database under the hood. You define model classes (with annotations or codegen) and Flutter Data handles CRUD operations through a unified API, syncing with a remote JSON/REST endpoint when available【32†L21-L29】【32†L45-L53】. It was built from the ground up for offline use: it caches data in Hive and automatically retries or syncs when connectivity is restored【32†L25-L32】. It also supports complex model relationships and reactive listeners.

**Features:**
- **Local Persistence:** Uses Hive for storing data on-device. Repositories serve as a *single source of truth* combining local & remote data【42†L470-L478】【32†L25-L32】. Your app can read/write models via the repository even while offline.
- **Sync & Retry:** Failed network operations are retried later. Flutter Data can queue writes and apply them when the device reconnects (ensuring eventual consistency). It supports defining custom remote endpoints for different actions【32†L21-L29】.
- **Conflict Handling:** There’s no elaborate conflict-resolution mechanism out of the box beyond last-write-wins. In practice, the “last” update (e.g. the one synced last) will overwrite previous data unless you implement custom logic. However, because it uses a repository pattern, you can intercept or manipulate how data is merged if needed.
- **Architecture Compatibility:** Flutter Data fits well in a Clean Architecture setup. The generated repositories (which you can inject via Provider, Riverpod, or get_it) represent the data layer【32†L41-L50】. You could wrap these in your own abstractions if desired, but many apps use the repositories directly as they adhere to SOLID principles (e.g. separation of concerns between local (Hive) storage and remote (HTTP) is internal to the library). It’s compatible with popular tools like Riverpod, Provider, and Freezed【32†L43-L51】.
- **Maturity:** It’s a **mature, actively maintained** library (v2.0+ as of 2025) with a stable API. Created by a developer with Flutter community presence, it’s used in production apps and well-documented【5†L55-L63】. Keep in mind it does introduce some learning curve (you’ll need to run build runners for code generation and learn its annotations), but once set up, it dramatically reduces boilerplate for offline-first logic.

**Known Limitations:** Because Flutter Data uses Hive (a key-value store), querying data with complex filters or SQL-like queries must be done in memory (or by writing Hive queries). If your app needs heavy local querying, a SQL-based solution might be preferable. Also, using Flutter Data means coupling with its repository/model structure – which is flexible but might be overkill for very simple use cases. Conflict resolution beyond simple last-wins or manual merge still falls on the developer if your use case is more complex (the library will sync data but doesn’t prompt about conflicts).

## Brick Offline-First (unified SQLite + REST)  
**Link:** [brick_offline_first on pub.dev](https://pub.dev/packages/brick_offline_first) – *by GetDutchie (includes Google Firebase team contributors)*  

**Summary:** Brick is an **“all-in-one” data manager** for offline-first apps. It uses code generation to create a repository that **combines an SQLite database and a REST API** into one interface【14†L66-L74】. When you request data, Brick will first try the local SQLite cache, and if needed, fetch from the remote API and **hydrate** (store) the results into SQLite before returning them【14†L66-L74】. This means your app can read/write through Brick’s repository the same way whether offline or online – the library abstracts the source. Brick was designed to support various backends (REST, Firebase, Supabase, etc.) via adapters.

**Functionality:**
- **Local-First Data Access:** Brick’s generated repository ensures that if data is available locally, the app can use it without hitting the network. The remote provider (e.g. your REST API client) is used to fetch fresh data which is then saved locally. Subsequent reads serve from SQLite, making offline access seamless【14†L66-L74】. You can also specify per-call policies, like forcing local-only or refreshing from network【14†L72-L76】.
- **Offline Creation & Sync:** Brick supports offline mutations (inserting/updating data). For example, calling an `upsert` on the repository will save the object to SQLite immediately. Under the hood it will also queue a network call to POST/PUT that data to the server. The exact timing can depend – Brick can attempt the network call immediately (and on success, update the local record with any server-supplied fields) or later based on connectivity. It doesn’t automatically run background services, but it provides the queue mechanism. The developer might need to trigger a sync or rely on Brick’s built-in behavior when the app reconnects.
- **Conflict Resolution:** Brick does **not have a built-in sophisticated conflict resolution system** – it generally assumes “last write wins” or that the remote is source of truth for merging. The **Brick OfflineFirst** domain focuses on caching and syncing, not multi-master conflict merging. If two devices edit the same entity offline, whichever syncs last to the server would overwrite fields (unless the server itself merges changes). Brick allows some control via policies (e.g. whether to prefer local data or remote in certain calls), but resolving field-level conflicts or merging changes is something you’d have to implement at the application or server level.
- **Clean Architecture Integration:** Brick can align with Clean Architecture, but it is somewhat **opinionated**. You will annotate your entity models with Brick’s annotations (like `@ConnectOfflineFirstWithRest`) and run code generation to get SQLite and REST mappers. The generated repository can be used in your data layer. You might wrap it in an interface (to decouple from Brick specifics in domain layer), or use it directly. Brick essentially **becomes your data layer**, handling both local and remote sources inside. This can still follow SOLID principles – e.g. the repository is a single responsibility (data access), and Brick keeps concerns separated internally. Developers have noted that Brick’s learning curve is a bit steep due to its configuration and codegen, but once set up it **reduces manual sync code**.
- **Maturity:** Brick Offline-First is fairly mature (version 4.x in 2024) and is maintained. It’s used in some projects (including Supabase examples)【18†L36-L43】. However, community feedback suggests it’s a **powerful but complex** solution. It generates a lot of boilerplate code for you, and the documentation is thorough but can be hard to digest. In production, it works, but you should budget time to understand Brick’s model and limitations.

**Limitations & Trade-offs:** Brick’s approach only caches data that your app has fetched or explicitly saved. It **does not automatically pull all data from the server**; you fetch what you need and then it’s available offline. This means if a user goes offline without previously fetching certain records, those records won’t be in the local DB (unlike some full replication systems). Also, because Brick abstracts data access, it doesn’t easily allow raw SQL queries; you typically query via repository methods or Brick’s query APIs. If you need fine-grained SQL querying or full text search locally, you might integrate Brick with direct SQLite access (or consider using a lower-level solution like Drift). Lastly, Brick’s conflict-handling is minimal – if your app needs custom merge logic for conflicts, you might need to implement additional checks (for instance, comparing timestamps or version numbers before upserting). 

## `offline_sync` (Pub package for queued sync)  
**Link:** [offline_sync on pub.dev](https://pub.dev/packages/offline_sync) – *community package (MIT licensed)*  

**Summary:** `offline_sync` is a lightweight Flutter plugin (currently v0.0.1) designed to **queue and sync data changes** with a remote server in an offline-first manner【1†L50-L58】. It provides a simple API to save data locally, which it then automatically synchronizes to a specified REST endpoint when connectivity is available【1†L50-L58】【2†L128-L136】. This package aims to handle the common boilerplate: local storage, detecting when network is back, retrying failed syncs, and even basic conflict resolution.

**Features:**
- **Local Storage & Queue:** Data is stored locally (using `sqflite` under the hood, plus `shared_preferences` for some meta-data)【2†L214-L221】. You typically call `offlineSync.saveLocalData(key, data)` to save an entity or record locally【2†L108-L116】. Each save is queued for sending to the server. The library assigns an ID (like `'user_1'` in the example) to identify records.
- **Automatic Background Sync:** The library listens for connectivity changes (via `connectivity_plus`) and will attempt to push any queued changes when an internet connection is restored【1†L50-L58】. You can also manually trigger a sync (e.g., `offlineSync.updateFromServer()`) to force a data refresh from the server【2†L130-L138】. Syncing is batched for efficiency and includes error handling & retry attempts【1†L70-L75】.
- **Conflict Resolution:** A basic **conflict resolution mechanism** is included. By default, the library will try a simple strategy (the documentation implies last-write-wins). It allows you to **override** the resolution logic by extending the `OfflineSync` class and implementing `resolveConflict(...)`【2†L153-L162】. For example, you could prefer local changes over server data or vice-versa in that method. This gives some flexibility in handling merge scenarios if the same record was modified both locally and remotely.
- **Integration:** `offline_sync` is relatively simple to integrate. You initialize a singleton `OfflineSync()` (optionally setting an API endpoint URL and auth token)【1†L99-L107】【2†L140-L148】. This could be done in your app’s startup (e.g., in an injected data service). In Clean Architecture terms, `offline_sync` can be treated as an **infrastructure detail** – for instance, your repository implementation can use `offlineSync.saveLocalData` for creates/updates and `offlineSync.readLocalData` for reads, hiding the sync mechanism behind your repository interface. Because it’s a small utility class, it doesn’t enforce any particular architecture.
- **Maturity:** This package is **very young** and not (yet) widely adopted (unverified publisher with a few hundred downloads). It was first published ~9 months ago and hasn’t seen a major update since, which suggests limited usage in the community. While it covers the basics (even encryption of data is mentioned as a feature【1†L70-L73】), you should evaluate it carefully in a real app. Being new, it might have undiscovered bugs or edge cases, and documentation beyond the README is sparse.

**Limitations:** As a lightweight solution, `offline_sync` is somewhat **opinionated in API design**. It uses a global endpoint for syncing – essentially expecting a REST API structure where all data can be sent to one base URL (possibly with IDs). This may not align with complex APIs that have multiple endpoints or require specific payload formats. You might need to customize it (by extending the class or contributing to the package) for advanced use cases. Also, it currently provides only a key-value style storage (each record stored under a string key). If your data model is complex (e.g., relational data with foreign keys or lists), you would need to manage how to structure it into that JSON map form. Lastly, conflict resolution is simplistic unless you override it; the default likely just overwrites older data with newer. Despite these trade-offs, `offline_sync` can jump-start a basic offline CRUD sync without writing the entire stack yourself.

## `offline_first_support` (Hive cache & sync helper)  
**Link:** [offline_first_support on pub.dev](https://pub.dev/packages/offline_first_support) – *community package (MIT)*  

**Summary:** This is another small package (v0.1.0, very recent) aiming to assist with offline-first data handling by using **Hive as a local cache**. It provides a simple API for fetching data with a given policy (network-first, cache-first, etc.), saving data to the cache, and watching for updates via Streams【24†L67-L75】【26†L111-L120】. Essentially, `offline_first_support` is a **cache layer** that you put in front of your REST API calls to easily store responses and serve them later offline.

**Functionality:**
- **Caching & Policies:** The core method is `offlineFirst.fetchData(urlPath, policy: ...)`. You can choose a policy such as `cacheOnly`, `networkOnly`, or `cacheThenNetwork`【26†L114-L122】. For example, using `cacheThenNetwork` will immediately return anything cached (so the UI has something to show offline or while waiting) and also trigger a network fetch in the background to update the cache. This is similar to Apollo GraphQL’s fetch policies or other caching libraries.
- **Local Persistence:** Hive is used under the hood for storing the data. You save data by providing a key and content (`offlineFirst.saveData(key, content)`)【26†L137-L146】. Typically, after a successful network call, the response JSON can be saved with a key. The library doesn’t enforce a schema – it’s up to you what key to use (e.g., a specific endpoint or query) and the content (likely the raw JSON or encoded string).
- **Offline Reads & Watchers:** If data is saved in the cache, `fetchData` with `cacheOnly` or `cacheThenNetwork` will retrieve it for offline use. Additionally, `offlineFirst.watchData(...)` returns a Stream that notifies when the cached data for a given key/url changes【26†L149-L158】. This is convenient for updating the UI in real-time whenever new data syncs in (for instance, after a background fetch updates the Hive cache, the Stream emits and your UI can rebuild with fresh data).
- **Integration:** `offline_first_support` is easy to integrate in a repository or data source class. You must call `OfflineFirst.init()` at app startup to initialize Hive【24†L95-L103】. After that, your repository can use the provided methods to wrap HTTP calls. For example, instead of using an `http.get` directly, you might call `offlineFirst.fetchData(urlPath: "/tasks", policy: cacheThenNetwork)`. The result includes a status and data payload【26†L125-L133】, which you then turn into your model (e.g., by decoding JSON). In Clean Architecture terms, this library can be seen as a utility in the data layer that provides caching; it doesn’t dictate your overall structure and can be hidden behind an interface (e.g., a `TaskRepository` that internally uses `offline_first_support`).
- **Maturity:** This package is **very new (published days ago)** and relatively unproven. It has a small number of likes/downloads. The idea it implements is straightforward, so it may work fine for basic use, but edge cases (like cache invalidation strategies, memory usage, etc.) might surface as it gets more adoption.

**Limitations:**
It’s important to note that `offline_first_support` **focuses on caching and reading data offline, but does not automatically sync offline edits back to the server**. If your use case is “make changes while offline and push them later,” this library alone won’t do that out of the box. You would have to implement the syncing of creates/updates: e.g., store pending changes (perhaps also in Hive) and then when online, send them via your API client and update the cache. The library doesn’t manage an “outbox” for you – it primarily ensures that fetched data is available offline. Also, conflict resolution isn’t within scope here; if the data on the server changes while the user is offline, the next `fetchData` will simply overwrite the cache with the server’s response (or you might choose to merge it yourself by reading the cache first). In summary, `offline_first_support` is a **partial solution (cache layer)**; you might pair it with your own syncing logic for a full offline-first system.
